#include <math.h>
#include "aldmg.h"

#define ALDMG_DEFAULT_SIZE 1024

typedef struct ALDMG_GUI ALDMG_GUI;


struct ALDMG_GUI {  
  ALDMG_WIDGET        * toplevel;   /* Toplevel widget. */
  size_t                space;      /* Amount of widget pointers in widgets */
  ALDMG_WIDGET       ** widgets;    /* Pointers to all widgets. */
  ALDMG_POINT           mouse;      /* Current mouse coordinates. */
  ALDMG_POINT           position;   /* Next widget position. */
  ALDMG_POINT           size;       /* Next widget position. */
  
  int                   click;      /* Recently clicked?. */

  
  int                   hover;
  int                   hot;
  ALLEGRO_EVENT         last_event;   
  ALLEGRO_DISPLAY     * display;
  ALLEGRO_EVENT_QUEUE * queue;
  ALLEGRO_FONT        * builtin_font;
};

/* Creates a widget for the given gui. */
ALDMG_WIDGET * aldmg_create_widget(ALDMG_GUI * gui) {
  ALDMG_WIDGET * widget = calloc(1, sizeof(ALDMG_WIDGET));
  widget->gui           = gui;  
  return widget;
}

/* Destroys a widget. */
void aldmg_destroy_widget(ALDMG_WIDGET * widget) {
  free(widget);
}


/** Adds more space for more widgets for this UI. Returns  negative if no space. */
int aldmg_grow(ALDMG_GUI * gui) {
  int index;
  ALDMG_WIDGET ** aid;
  if (!gui) return -2;  
  aid = realloc(gui->widgets, (gui->space + ALDMG_DEFAULT_SIZE) * sizeof(ALDMG_WIDGET *));
  if (!aid) return -1;
  
  for (index = gui->space ; index < gui->space + ALDMG_DEFAULT_SIZE ; index ++) {
    aid[index] = NULL;
  }  
  gui->widgets = aid;  
  gui->space  += ALDMG_DEFAULT_SIZE;
  return 0;
}

/* Creates a gui for a given display and event queue. */
ALDMG_GUI * aldmg_create_gui(ALLEGRO_DISPLAY * display, ALLEGRO_EVENT_QUEUE * queue) 
{
  ALDMG_GUI * gui = calloc(1, sizeof(ALDMG_GUI));
  if (!gui) return NULL;
  gui->queue        = queue;
  gui->display      = display;
  gui->space        = 0;
  /* gui->widgets      = calloc(gui->space, sizeof(ALDMG_WIDGET *)); */
  aldmg_grow(gui);
  
  gui->builtin_font = al_create_builtin_font();
  gui->toplevel     = aldmg_create_widget(gui);  
  
  if ((!gui->toplevel) || (!gui->widgets) || (!gui->builtin_font)) {
    aldmg_destroy_gui(gui);
    return NULL;
  }
  
  gui->mouse.x      = 0;
  gui->mouse.y      = 0;
  gui->position.x   = 0;
  gui->position.y   = 0;
  gui->size.x       = 16.0;
  gui->size.y       = 16.0;
  gui->click        = 0;
    
  return gui;
}

/* Destroys a GUI after use. */
void aldmg_destroy_gui(ALDMG_GUI * gui) 
{
  if (!gui) return;
    
  if (gui->builtin_font) { 
    al_destroy_font(gui->builtin_font);
  }
  
  if (gui->widgets) {
    int index;
    for (index = 0; index < gui->space; index++) {
      aldmg_destroy_widget(gui->widgets[index]);
      gui->widgets[index] = NULL;
    }
    free(gui->widgets);
    gui->widgets = NULL;
  }
    
  free(gui);  
}


/** Gets a widget for the given id. Returns NULL if no such widget. */
ALDMG_WIDGET * aldmg_get_widget(ALDMG_GUI * gui, int id) {
  if (!gui) return NULL;
  if (!gui->widgets) return NULL;
  if (id < 0) return NULL;
  if (id >= gui->space) return NULL;
  return gui->widgets[id];
}

/** Returns a free id for a widget. Returns negative if no space. */
int aldmg_get_id(ALDMG_GUI * gui) {
  int index;
  if (!gui) return -2;
  if (!gui->widgets) return -3;
  for (index = 0; index < gui->space ; index ++) {
    if (!gui->widgets[index]) return index;    
  }
  return -1;
}


/** Adds an existing widget to the gui with the given id. */
ALDMG_WIDGET * aldmg_put_widget(ALDMG_GUI * gui, int id, ALDMG_WIDGET * widget) {
  if (!gui) return NULL;  
  if (!gui->widgets) return NULL;
  if (id < 0) return NULL;
  if (id >= gui->space) return NULL;  
  gui->widgets[id] = widget;
  widget->id = id;
  return widget;
}

/** Adds a new widget to the GUI. ID is autogenerated and stored in id. */
ALDMG_WIDGET * aldmg_new_widget(ALDMG_GUI * gui, int id) {
  ALDMG_WIDGET * widget;
  if (id < 0) return NULL;  
  while (id >= gui->space)  {
    if (aldmg_grow(gui) < 0) return NULL;
  }  
  widget = aldmg_create_widget(gui);
  if (!widget) return NULL;  
  return aldmg_put_widget(gui, id, widget);  
}

/** Looks up the widget by id. If it doesn't exits yet, creates it. 
 * May still return null if creation failed.  */
ALDMG_WIDGET * aldmg_require_widget(ALDMG_GUI * gui, int id) {
  ALDMG_WIDGET * widget = aldmg_get_widget(gui, id);
  if (widget) return widget;
  return aldmg_new_widget(gui, id);
}




int aldmg_handle_key_down(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_key_up(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_key_char(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_mouse_button_down(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  gui->mouse.x = event->mouse.x;
  gui->mouse.y = event->mouse.y;  
  gui->click   = 1;
  return 1;
}

int aldmg_handle_mouse_button_up(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  gui->mouse.x = event->mouse.x;
  gui->mouse.y = event->mouse.y;  
  gui->click   = 0;
  return 1;
}

int aldmg_handle_mouse_axes(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  gui->mouse.x = event->mouse.x;
  gui->mouse.y = event->mouse.y;  
  gui->click   = 0;
  return 1;
}

int aldmg_handle_mouse_enter_display(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  gui->mouse.x = event->mouse.x;
  gui->mouse.y = event->mouse.y;  
  gui->click   = 0;  
  return 1;
}

int aldmg_handle_mouse_leave_display(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  gui->mouse.x = event->mouse.x;
  gui->mouse.y = event->mouse.y;  
  gui->click   = 0;
  return 1;
}

int aldmg_handle_mouse_warped(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_joystick_button_down(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_joystick_button_up(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}

int aldmg_handle_joystick_axes(ALDMG_GUI * gui, ALLEGRO_EVENT * event) {
  return 0;
}



/* Handles an incoming Allegro event. Returns zero if the event was not 
 * processed  by thegui, nonzero if it was and the rest of your program can 
 * ignore it if you like. 
 */
int aldmg_handle_event(ALDMG_GUI * gui, ALLEGRO_EVENT * event) 
{
  if (!event) return 0;
  gui->last_event = (*event);
  
  switch (event->type) {    
    case ALLEGRO_EVENT_KEY_DOWN:
      return aldmg_handle_key_down(gui, event);
      
    case ALLEGRO_EVENT_KEY_UP:
      return aldmg_handle_key_up(gui, event);
      
    case ALLEGRO_EVENT_KEY_CHAR:
      return aldmg_handle_key_char(gui, event);
                  
    case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
      return aldmg_handle_mouse_button_down(gui, event);
      
    case ALLEGRO_EVENT_MOUSE_BUTTON_UP:
      return aldmg_handle_mouse_button_up(gui, event);      
      
    case ALLEGRO_EVENT_MOUSE_AXES:
      return aldmg_handle_mouse_axes(gui, event);
      
    case ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY:
      return aldmg_handle_mouse_enter_display(gui, event);
      
    case ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY:
      return aldmg_handle_mouse_leave_display(gui, event);
      
    case ALLEGRO_EVENT_MOUSE_WARPED:
      return aldmg_handle_mouse_warped(gui, event);      
      
    case ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN:
      return aldmg_handle_joystick_button_down(gui, event);
      
    case ALLEGRO_EVENT_JOYSTICK_BUTTON_UP:
      return aldmg_handle_joystick_button_up(gui, event);      
      
    case ALLEGRO_EVENT_JOYSTICK_AXIS:
      return aldmg_handle_joystick_axes(gui, event);
          
    default: /* Unrecognised or non-gui related event. */
      return 0;      
  }
  
  return 0;
}

/* Updates the timer of the gui to do animations, etc. */
void aldmg_update_gui(ALDMG_GUI * gui, double dt) 
{
  
}

/* Draws  the GUI. */
void aldmg_draw_gui(ALDMG_GUI * gui) 
{
  
}

/* Returns a pointer to the toplevel widget of the GUI. This always exists, 
 * but normally simply does nothing but draw it's background if set. The id 
 * of the toplevel widget is 0. 
 */
ALDMG_WIDGET * aldmg_get_toplevel_widget_from_gui(ALDMG_GUI * gui);


/* Returns a box with the given position and size. */
ALDMG_BOX aldmg_box(float x, float y, float w, float h);

/* Returns a default style for the GUI. 
 * The font will be an instane of Allegro's built-in font. */
ALDMG_STYLE aldmg_get_default_style(ALDMG_GUI * gui);

/** Indicates the beginning of the gui handling and setup. */
int aldmg_start_gui(ALDMG_GUI * gui) {
  return 0;
}

/** Indicates the end of the gui handling and setup. */
int aldmg_end_gui(ALDMG_GUI * gui) {
  return 0;
}

/* Adds and handles a custom widget to the GUI. */
int aldmg_custom_widget(ALDMG_GUI * gui, ALDMG_WIDGET * widget, ...);

/* Adds and handles a custom widget to the GUI. */
int aldmg_custom_widget_va(ALDMG_GUI * gui, ALDMG_WIDGET * widget, va_list args);

/* Indicates the end of a container-style custom widget. 
 * Not needed for non-containers. */
int aldmg_end_custom_widget(ALDMG_GUI * gui, ALDMG_WIDGET * widget);


/* Indicates the end of a container-style built in widget. 
 * Not needed for non-containers. */
int aldmg_end_widget(ALDMG_GUI * gui, int id);

/* Adds a logical GUI page to the GUI and/or handles it's state. */  
int aldmg_page(ALDMG_GUI * gui, int id, ...);

/* Adds a logical GUI page to the GUI and/or handles it's state. */  
int aldmg_page_va(ALDMG_GUI * gui, int id, va_list args);

/* Adds a frame to the GUI and/or handles it's state. */  
int aldmg_frame(ALDMG_GUI * gui, int id, ...);

int aldmg_mouse_inside(ALDMG_GUI * gui, int x, int y, int w, int h) {
  return (gui->mouse.x >= x) 
      && (gui->mouse.y >= y) 
      && (gui->mouse.x <= (x+w))
      && (gui->mouse.y <= (y+h));
}

  
float aldmg_y_percentage_to_real(ALDMG_GUI * gui, float ydim) {
  float dh = al_get_display_height(gui->display);
  return round((dh * ydim) / 8.0) * 8.0;
}

  
float aldmg_x_percentage_to_real(ALDMG_GUI * gui, float xdim) {
  float dw = al_get_display_width(gui->display);
  return round((dw * xdim) / 8.0) * 8.0;  
}


/* Sets the position for the next widget. */
ALDMG_GUI * aldmg_set_position(ALDMG_GUI * gui, float px, float py) {
  gui->position.x = px;
  gui->position.y = py;
  return gui;
}

/* Sets the style for the next widget. */
ALDMG_GUI * aldmg_set_style(ALDMG_GUI * gui, ALDMG_STYLE style);

/* Sets the size for the next widget. GUI is returned for chaining.*/
ALDMG_GUI * aldmg_set_size(ALDMG_GUI * gui, float pw, float ph) {
  gui->size.x = pw;
  gui->size.y = ph;
  return gui;
}


/* Draws a label with variable formating. */
int aldmg_vlabelf(ALDMG_GUI * gui, int id, char * format, va_list args) {
  char buffer[1024];
  int x = gui->position.x;
  int y = gui->position.y;
  int w = gui->size.x;
  int h = gui->size.y;
  int m = 2;
  
  gui->position.x += w;
  if (gui->position.x > al_get_display_width(gui->display)) {
     gui->position.x += 0;
     gui->position.y += h;
  }
  
  vsnprintf(buffer, sizeof(buffer), format, args);
  al_draw_text(gui->builtin_font, al_map_rgb(255,255,255),  x + m , y + m, 0, buffer);
  return 1;  
}

int aldmg_labelf(ALDMG_GUI * gui, int id, char * format, ...) {
  int result;
  va_list args;
  va_start(args, format);
  result = aldmg_vlabelf(gui, id, format, args);
  va_end(args);
  return result;  
}



/* Adds a button the the GUI and/or handles it's state. */  
int aldmg_button(ALDMG_GUI * gui, int id, char * label) {
  ALDMG_WIDGET * widget = aldmg_require_widget(gui, id);
  int x = gui->position.x;
  int y = gui->position.y;
  int w = gui->size.x;
  int h = gui->size.y;
  int m = 2;
  int inside;
    
  gui->position.x    += w;
  if (gui->position.x > al_get_display_width(gui->display)) {
     gui->position.x += 0;
     gui->position.y += h;
  }
  
  inside = aldmg_mouse_inside(gui, x, y, w, h);
  if (inside) { 
    al_draw_filled_rounded_rectangle(x, y, x + w, y + h, 2, 2, al_map_rgb(0,0,255));
  } else {
    al_draw_filled_rounded_rectangle(x, y, x + w, y + h, 2, 2, al_map_rgb(0,0,128));
  }
  al_draw_rounded_rectangle(x, y, x + w, y + h, 2, 2, al_map_rgb(255,255,255), 2);  
  al_draw_textf(gui->builtin_font, al_map_rgb(255,255,255),  x + m , y + m, 0, "%s", label);
  if (inside && gui->click) {
    gui->click = 0;
    return 1;
  }
  
  return 0;
}




/* Adds a vertical menu to the GUI and/or handles it's state. */  
int aldmg_vmenu(ALDMG_GUI * gui, int id, ...);

/* Adds a menu item to the GUI and/or handles it's state. */  
int aldmg_item(ALDMG_GUI * gui, int id, ...);


